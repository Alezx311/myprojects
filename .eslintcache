[{"C:\\Programming\\myprojects\\src\\index.js":"1","C:\\Programming\\myprojects\\src\\App.js":"2","C:\\Programming\\myprojects\\src\\store\\reducers.js":"3","C:\\Programming\\myprojects\\src\\store\\types.js":"4","C:\\Programming\\myprojects\\src\\components\\MelodyGenerator\\index.js":"5","C:\\Programming\\myprojects\\src\\components\\MelodyGenerator\\View.js":"6","C:\\Programming\\myprojects\\src\\components\\MelodyGenerator\\Setup.js":"7","C:\\Programming\\myprojects\\src\\components\\MelodyGenerator\\List.js":"8","C:\\Programming\\myprojects\\src\\store\\actions.js":"9","C:\\Programming\\myprojects\\src\\components\\MelodyGenerator\\ListElements.js":"10","C:\\Programming\\myprojects\\src\\components\\reactHelpers.js":"11","C:\\Programming\\myprojects\\src\\components\\GuitarFretboard\\index.js":"12","C:\\Programming\\myprojects\\src\\components\\toneHelpers.js":"13","C:\\Programming\\myprojects\\src\\components\\MelodyGenerator\\Player.js":"14","C:\\Programming\\myprojects\\src\\components\\MelodyGenerator\\Helpers.js":"15","C:\\Programming\\myprojects\\src\\components\\samples\\index.js":"16"},{"size":533,"mtime":1611790715148,"results":"17","hashOfConfig":"18"},{"size":489,"mtime":1611816760669,"results":"19","hashOfConfig":"18"},{"size":2035,"mtime":1612377961796,"results":"20","hashOfConfig":"18"},{"size":284,"mtime":1611777366644,"results":"21","hashOfConfig":"18"},{"size":467,"mtime":1611817433783,"results":"22","hashOfConfig":"18"},{"size":2372,"mtime":1611827548455,"results":"23","hashOfConfig":"18"},{"size":2600,"mtime":1611802776117,"results":"24","hashOfConfig":"18"},{"size":1888,"mtime":1611799182433,"results":"25","hashOfConfig":"18"},{"size":474,"mtime":1611778738161,"results":"26","hashOfConfig":"18"},{"size":1636,"mtime":1611765329806,"results":"27","hashOfConfig":"18"},{"size":475,"mtime":1611758191336,"results":"28","hashOfConfig":"18"},{"size":3267,"mtime":1611819983909,"results":"29","hashOfConfig":"18"},{"size":2483,"mtime":1611073950777,"results":"30","hashOfConfig":"18"},{"size":1707,"mtime":1611827741833,"results":"31","hashOfConfig":"18"},{"size":31167,"mtime":1612379971282,"results":"32","hashOfConfig":"18"},{"size":8508,"mtime":1612345789431,"results":"33","hashOfConfig":"18"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"1uqnke4",{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"45","usedDeprecatedRules":"36"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"48","usedDeprecatedRules":"36"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"57"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"68"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"C:\\Programming\\myprojects\\src\\index.js",[],["71","72"],"C:\\Programming\\myprojects\\src\\App.js",[],"C:\\Programming\\myprojects\\src\\store\\reducers.js",[],"C:\\Programming\\myprojects\\src\\store\\types.js",[],"C:\\Programming\\myprojects\\src\\components\\MelodyGenerator\\index.js",["73"],"import React from 'react'\r\n\r\nimport Setup from './Setup'\r\nimport View from './View'\r\nimport List from './List'\r\nimport Player from './Player'\r\n\r\nconst MelodyGenerator = () => (\r\n  <div className=\"col\">\r\n    <div className=\"row\">\r\n      <Setup />\r\n    </div>\r\n    <div className=\"row\">\r\n      <Player />\r\n    </div>\r\n    <div className=\"row\">{/* <View /> */}</div>\r\n    <div className=\"row\">\r\n      <List />\r\n    </div>\r\n  </div>\r\n)\r\n\r\nexport default MelodyGenerator\r\n","C:\\Programming\\myprojects\\src\\components\\MelodyGenerator\\View.js",["74","75","76","77"],"import React from 'react'\r\nimport ReactJson from 'react-json-view'\r\nimport Sketch from 'react-p5'\r\nimport { useSelector } from 'react-redux'\r\n\r\nconst CanvasValues = {\r\n  width: 500,\r\n  height: 500,\r\n  // notesExample: ['c', 'f', 'bb', 'g', 'f', 'c', 'bb', 'c', 'f', 'f'],\r\n  notesExample: ['a', 'ab', 'b', 'bb', 'c', 'd', 'db', 'e', 'eb', 'f', 'g', 'gb'],\r\n  notesColors: {\r\n    a: '#00ff00',\r\n    ab: '#8000ff',\r\n    b: '#00ffff',\r\n    bb: '#ff80c0',\r\n    c: '#ff0000',\r\n    d: '#ffff00',\r\n    db: '#ff00ff',\r\n    e: '#0080c0',\r\n    eb: '#808080',\r\n    f: '#800000',\r\n    g: '#ff8000',\r\n    gb: '#8080c0'\r\n  }\r\n}\r\nconst noteToColor = note => CanvasValues.notesColors?.[note] ?? '#808000'\r\n\r\nconst ViewSketch = ({ size = 300 }) => {\r\n  const setup = (p5, canvasParentRef) => {\r\n    p5.createCanvas(size, size).parent(canvasParentRef)\r\n  }\r\n\r\n  const draw = p5 => {\r\n    const { width, height, figureWidth, figureHeight, notesExample, notesColors } = CanvasValues\r\n    const noteElementSize = width / notesExample.length\r\n\r\n    p5.background(0)\r\n\r\n    notesExample.map((v, i) => {\r\n      let posX = noteElementSize * i + noteElementSize / 2\r\n      let posY = height / 2\r\n      const color = noteToColor(v)\r\n\r\n      // posY = Math.random() > 0.5 ? posY + ~~(Math.random() * 10) : posY - ~~(Math.random() * 10)\r\n      p5.ellipse(posX, posY, noteElementSize, noteElementSize).fill(color)\r\n    })\r\n  }\r\n\r\n  return (\r\n    <div className=\"text-center align-middle\">\r\n      <Sketch setup={setup} draw={draw} />\r\n    </div>\r\n  )\r\n}\r\n\r\nconst ViewPlayer = () => {\r\n  const { player } = useSelector(state => state)\r\n  return (\r\n    <div className=\"col\">\r\n      <label>Player</label>\r\n      <ReactJson src={player.melody?.mainNotes} />\r\n    </div>\r\n  )\r\n}\r\nconst ViewSound = () => {\r\n  const { sound } = useSelector(state => state)\r\n  return (\r\n    <div className=\"col\">\r\n      <label>Sound</label>\r\n      <ReactJson src={sound} />\r\n    </div>\r\n  )\r\n}\r\nconst ViewFretboard = () => {\r\n  const { fretboard } = useSelector(state => state)\r\n  return (\r\n    <div className=\"col\">\r\n      <label>Fretboard</label>\r\n      <ReactJson src={fretboard} />\r\n    </div>\r\n  )\r\n}\r\n\r\nconst View = () => (\r\n  <div className=\"container\">\r\n    <div className=\"row\">\r\n      <ViewPlayer />\r\n      <ViewSound />\r\n      <ViewFretboard />\r\n      <ViewSketch />\r\n    </div>\r\n  </div>\r\n)\r\n\r\nexport default View\r\n","C:\\Programming\\myprojects\\src\\components\\MelodyGenerator\\Setup.js",[],"C:\\Programming\\myprojects\\src\\components\\MelodyGenerator\\List.js",[],"C:\\Programming\\myprojects\\src\\store\\actions.js",[],"C:\\Programming\\myprojects\\src\\components\\MelodyGenerator\\ListElements.js",[],["78","79"],"C:\\Programming\\myprojects\\src\\components\\reactHelpers.js",[],"C:\\Programming\\myprojects\\src\\components\\GuitarFretboard\\index.js",[],"C:\\Programming\\myprojects\\src\\components\\toneHelpers.js",[],"C:\\Programming\\myprojects\\src\\components\\MelodyGenerator\\Player.js",[],"C:\\Programming\\myprojects\\src\\components\\MelodyGenerator\\Helpers.js",["80","81","82","83","84","85"],"import * as Teoria from 'teoria'\r\nimport * as Tone from 'tone'\r\nimport { Joi } from 'joi'\r\nimport SAMPLE_NOTES from '../samples/'\r\n\r\n//! class Random is generate functions, for easy work, test, processing, etc...\r\nexport class Random {\r\n  //* generate random range -> range > 0.01 && range < 0.99\r\n  static Range = () => +(0.5 + Math.random() / 5).toFixed(2)\r\n  //* generate random number -> number > min && number < max\r\n  static Number = (min = 1, max = 100) => Math.floor(Math.random() * (max - min + 1)) + min\r\n  //* generate random power of 2 number -> 2,4,8,16,32,64...\r\n  static PowerOfTwo = (maxPower = 5) => 2 ** this.Number(1, maxPower)\r\n  //* generate random array with given length\r\n  static Array = (arrayLength = 10) => Array(arrayLength).fill(1)\r\n  //* generate random array with given length and random range values\r\n  static Values = (arrayLength = 10) => this.Array(arrayLength).map(this.Range)\r\n  //* get random element from given array\r\n  static ArrayElement = (arr = ['invalid array']) => [...arr, ...arr][this.Number(0, arr.length)]\r\n  //* shuffle given array\r\n  static ArrayShuffle = (arr = []) => [...new Set([...arr, ...arr, ...arr].sort((a, b) => Math.random() - 0.5))]\r\n  //* get random note char like: 'c', 'd#', 'bb' with possible '#' and 'b' symbols\r\n  static NoteChar = (notesArray = NOTES) => this.ArrayElement(notesArray).toUpperCase()\r\n  //* get random octave in given range (min is 1 and max is 6 for default)\r\n  static Octave = (min = 1, max = 6) => this.Number(min, max)\r\n  //* get random note char and join it with octave like: 'c2', 'd3', 'bb5'...\r\n  static NoteCharAndOctave = (notesArray = NOTES, min = 2) =>\r\n    `${this.ArrayElement(notesArray)}${this.Octave(min, min + 1)}`\r\n  //* get random guitar tuning name\r\n  static TuningName = () => this.ArrayElement(TUNING_NAMES)\r\n  //* get random musical scale name\r\n  static ScaleName = () => this.ArrayElement(SCALES)\r\n  //* get random music note duration symbol\r\n  static DurationSymbol = () => this.ArrayElement(DURATION_SYMBOLS)\r\n  //* get random music note duration value and symbol. for example, '1n' is full note, '4n' is fourth\r\n  static DurationRelative = () => `${this.PowerOfTwo()}${this.DurationSymbol()}`\r\n  //* get array with durations\r\n  static DurationRelativesArray = (arrayLength = 10) => this.Array(arrayLength).map(v => this.DurationRelative())\r\n  //* get absolute duration value. 1 is one second, for example\r\n  static DurationAbsolute = () => this.Range()\r\n  //* get array with absolute durations\r\n  static DurationAbsolutesArray = (arrayLength = 10) => this.Array(arrayLength).map(v => this.DurationAbsolute())\r\n  //* get random instrument name, like: 'cello', 'violin', ...\r\n  static InstrumentName = () => this.ArrayElement(INSTRUMENT_NAMES)\r\n  //* get random synth name, like: 'polysynth', 'fmsynth', ...\r\n  static SynthName = () => this.ArrayElement(SYNTH_NAMES)\r\n  //* get random sample name, match with instrument name, but can be changed in future\r\n  static SampleName = () => this.ArrayElement(SAMPLE_NAMES)\r\n  //* get possible note samples for random sample instrument\r\n  static SampleNoteNames = () => Object.keys(SAMPLES[this.SampleName()])\r\n  //* Random Bpm, in given range\r\n  static Bpm = (min = 60, max = 120) => this.Number(min, max)\r\n  //* Random Color, from given array, or HEX note colors\r\n  static Color = (colorsArray = COLORS) => this.ArrayElement(colorsArray)\r\n  //* Random Size, in given range, as square side length\r\n  static Size = (min = 1, max = 100) => this.Number(min, max)\r\n  //* Random Position, in given range, as { x, y}\r\n  static Position = (min = 0, max = 100) => ({ x: this.Number(min, max), y: this.Number(min, max) })\r\n  //* Random Velocity, in given range\r\n  static Velocity = (min = 0.5) => 1 - (Math.random() * min).toFixed(2)\r\n  //* Random Note Object with all values for play sound. Generated from given values\r\n  static NoteObject = (notesArray = NOTES, minOctave = 2) => {\r\n    const noteChar = this.NoteChar(notesArray)\r\n    const octave = this.Octave(minOctave, minOctave + 2)\r\n    const noteAndOctave = `${noteChar}${octave}`\r\n    const duration = this.DurationRelative()\r\n    const velocity = this.Velocity()\r\n    const color = NOTE_COLORS[noteChar]\r\n\r\n    return { noteChar, octave, noteAndOctave, duration, velocity, color }\r\n  }\r\n  //* Change some given array elements for random array element with given chance\r\n  static ArrayChangeSome = (array, chance = 10) =>\r\n    array.map((v, i, a) => {\r\n      if (this.Number() > chance) return this.ArrayElement(a)\r\n      else return v\r\n    })\r\n  //* Generate Music Phrases of note objects\r\n  static Phrases = (noteChar, scaleName, minOctave = 2, phrasesLength = 20) => {\r\n    if (!noteChar || !SCALES.includes(scaleName)) {\r\n      throw new Error({\r\n        message: 'Invalid values to generate Phrases',\r\n        data: { noteChar, scaleName, minOctave, phrasesLength }\r\n      })\r\n    }\r\n\r\n    const { Note, Scale, Chord, Intervals, Info } = Helpers.NoteValues(noteChar, scaleName)\r\n\r\n    const chordNotes = Chord.notes().toString()\r\n    const scaleNotes = Scale.simple()\r\n    const intervalScaleNotes = Intervals.scale.arpeggio\r\n    const intervalStepsNotes = Intervals.steps.arpeggio\r\n\r\n    const fromChordNotes = this.Array(phrasesLength).map(v => this.NoteObject(chordNotes, minOctave))\r\n    const fromScaleNotes = this.Array(phrasesLength).map(v => this.NoteObject(scaleNotes, minOctave))\r\n    const fromIntervalsScale = this.Array(phrasesLength).map(v => this.NoteObject(intervalScaleNotes, minOctave))\r\n    const fromIntervalsSteps = this.Array(phrasesLength).map(v => this.NoteObject(intervalStepsNotes, minOctave))\r\n\r\n    const fromMerging = Helpers.ArrayMerge(fromChordNotes, fromScaleNotes, fromIntervalsScale, fromIntervalsSteps)\r\n\r\n    const randomElement = this.ArrayElement(fromMerging)\r\n\r\n    const generateInfo = `Random Element Check fromMerging:\r\n\r\nLength: ${fromMerging.length}\r\nfromMerging randomElement.noteChar: ${randomElement.noteChar}\r\nfromMerging randomElement.octave: ${randomElement.octave}\r\nfromMerging randomElement.noteAndOctave: ${randomElement.noteAndOctave}\r\nfromMerging randomElement.duration: ${randomElement.duration}\r\nfromMerging randomElement.velocity: ${randomElement.velocity}\r\nfromMerging randomElement.color: ${randomElement.color}\r\n\r\nfromChordNotes randomElement:\\n${Object.entries(fromChordNotes[1]).join('\\n')}\\n\r\nfromScaleNotes randomElement:\\n${Object.entries(fromScaleNotes[1]).join('\\n')}\\n\r\nfromIntervalsScale randomElement:\\n${Object.entries(fromIntervalsScale[1]).join('\\n')}\\n\r\nfromIntervalsSteps randomElement:\\n${Object.entries(fromIntervalsSteps[1]).join('\\n')}\\n`\r\n\r\n    return {\r\n      fromChordNotes,\r\n      fromScaleNotes,\r\n      fromIntervalsScale,\r\n      fromIntervalsSteps,\r\n      fromMerging,\r\n      Note,\r\n      Info,\r\n      generateInfo\r\n    }\r\n  }\r\n  //* Generate simple melody with note objects\r\n  static SimpleMelody = (noteChar, scaleName, minOctave = 2, melodyLength = 16) => {\r\n    const { Note, Scale, Chord, Intervals, Roots, Notes } = Helpers.TeoriaValues(noteChar, scaleName)\r\n    const scaleNotes = Scale.simple()\r\n    const chordNotes = Chord.notes().toString().split(',')\r\n\r\n    const getPatternMelody = () => this.Array(melodyLength).map(v => this.NoteObject(scaleNotes, minOctave))\r\n    const patternMelody = getPatternMelody()\r\n\r\n    const getScaleMelody = () => patternMelody.map(v => this.NoteObject(scaleNotes, minOctave))\r\n    const getChordsMelody = () => patternMelody.map(v => this.NoteObject(chordNotes, minOctave))\r\n    const getRootsMelody = () => patternMelody.map(v => this.NoteObject(Roots, minOctave))\r\n    const getIntervalsMelody = () => patternMelody.map(v => this.NoteObject(Notes, minOctave))\r\n\r\n    const generate = (pattern = patternMelody, chance = this.Number()) => {\r\n      const scale = this.ArrayChangeSome(getScaleMelody(), chance)\r\n      const chords = this.ArrayChangeSome(getChordsMelody(), chance)\r\n      const roots = this.ArrayChangeSome(getRootsMelody(), chance)\r\n      const intervals = this.ArrayChangeSome(getIntervalsMelody(), chance)\r\n\r\n      const merged = Helpers.ArrayMerge(pattern, scale, chords, roots, intervals)\r\n      const flatted = this.ArrayChangeSome(merged, chance).flat('Infinite')\r\n\r\n      return Helpers.ArrayMerge(pattern, scale, chords, roots, intervals, merged, flatted)\r\n    }\r\n\r\n    const simple = generate()\r\n\r\n    console.log(`Simple Melody created.\r\n    Length: ${simple.length}\r\n    Unical Notes: ${this.ArrayUnicals(simple.map(v => v.noteAndOctave))}\r\n    Interval Moves: ${simple.reduce(\r\n      (acc, val, ind) => {\r\n        const [diff1, diff2] = [ind, acc.ind].sort((a, b) => a - b)\r\n        const step = Helpers.IntervalBetween(acc.noteChar, val.noteChar)\r\n        const diff = diff1 - diff2\r\n        const message = `Move interval: ${step}\\nDifference: ${diff}\\nAccumulator: ${acc}\\nValue: ${val}`\r\n        const move = { step, diff, message, ind, val }\r\n        const state = { ...acc, ...move }\r\n\r\n        console.log('step', step)\r\n        console.log('diff', diff)\r\n        console.log('message', message)\r\n        console.log('move', move)\r\n        console.log('state', state)\r\n\r\n        return state\r\n      },\r\n      { step: '', ind: -1, noteChar: 'some...' }\r\n    )}\r\n    `)\r\n\r\n    return simple\r\n  }\r\n  //TODO Generate Bass Instrument Melody, to match sound with exists melody\r\n  static BassMelody = (melody, bpm = 60) => {\r\n    const melodyNotes = Helpers.ArrayUnicals(melody.reduce((a, v) => a.push(v.noteAndOctave), []))\r\n    const phrases = Helpers.ArrayUnicals(this.Array(100).map(v => this.ArrayShuffle(melodyNotes)))\r\n\r\n    console.log(melodyNotes)\r\n    console.log(phrases)\r\n  }\r\n  //TODO Generate Drum Instrument Melody, to match sound with exists melody\r\n  static DrumMelody = (melody, bpm = 60) => {\r\n    const melodyNotes = Helpers.ArrayUnicals(melody.reduce((a, v) => a.push(v.noteAndOctave), []))\r\n    const phrases = Helpers.ArrayUnicals(this.Array(100).map(v => this.ArrayShuffle(melodyNotes)))\r\n\r\n    console.log(melodyNotes)\r\n    console.log(phrases)\r\n  }\r\n  //TODO Generate Lead Instrument Melody, to match sound with exists melody\r\n  static LeadMelody = (melody, bpm = 60) => {\r\n    const melodyNotes = Helpers.ArrayUnicals(melody.reduce((a, v) => a.push(v.noteAndOctave), []))\r\n    const phrases = Helpers.ArrayUnicals(this.Array(100).map(v => this.ArrayShuffle(melodyNotes)))\r\n\r\n    console.log(melodyNotes)\r\n    console.log(phrases)\r\n  }\r\n  //TODO Generate Guitar Melody, to match sound with exists melody\r\n  static GuitarMelody = (melody = 2, bpm = 60) => {\r\n    const melodyNotes = Helpers.ArrayUnicals(melody.reduce((a, v) => a.push(v.noteAndOctave), []))\r\n    const phrases = Helpers.ArrayUnicals(this.Array(100).map(v => this.ArrayShuffle(melodyNotes)))\r\n\r\n    console.log(melodyNotes)\r\n    console.log(phrases)\r\n  }\r\n}\r\n//! Helpers is class with very useful methods, for easy use in any place\r\nexport default class Helpers {\r\n  //* Unical Array Elements\r\n  static ArrayUnicals = arr => [...new Set([...arr])]\r\n  //* Can work with any number of arrays, always return one merged array, with unical values of all given arrays\r\n  static ArrayMerge = (arr, ...rest) => [...new Set([...arr, ...rest.flat()])]\r\n  //* Convert Note Char to HEX Color\r\n  static NoteToColor = str => NOTE_COLORS?.[str] ?? false\r\n  //* Convert HEX Color to Note Char\r\n  static ColorToNote = str => Object.entries(NOTE_COLORS).find(([key, value]) => value === str)?.[0] ?? false\r\n  //* Doubled random array element, useful on melody generate. For example, [1,2,3] -> [1,[2,2],3]\r\n  static SomeArrayElementDouble = array => {\r\n    const elementIndex = Random.Number(0, array.length)\r\n    const doubled = [array[elementIndex], array[elementIndex]]\r\n    array[elementIndex] = doubled\r\n\r\n    return array\r\n  }\r\n  //* Change random array element, useful on melody generate. For example, [1,2,3] -> [1,3,3]\r\n  static SomeArrayElementChange = array => {\r\n    array[Random.Number(0, array.length)] = array[Random.Number(0, array.length)]\r\n\r\n    return array\r\n  }\r\n  //* Split Note And Octave from String, and return an object { noteChar, octave }\r\n  static SplitNoteAndOctave = str => {\r\n    const noteChar = str.match(/^[a-g#]+/i)?.[0] ?? false\r\n    const octave = str.match(/[1-6]$/i)?.[0] ?? false\r\n\r\n    return { noteChar, octave }\r\n  }\r\n  //* Getter for Teoria intervals for note and scale\r\n  static TeoriaIntervals = (noteChar, scaleName) =>\r\n    noteChar?.scale(scaleName).simple() ?? Teoria.note(noteChar).scale(scaleName)\r\n  //* Getter for all Teoria values fro note and scale { note, scale, chord tonical and elements, all interval roots and elements}\r\n  static TeoriaValues = (noteChar, scaleName) => {\r\n    const Note = Teoria.note(noteChar)\r\n    const Chord = Note.chord()\r\n    const Scale = Note.scale(scaleName)\r\n    const Intervals = Scale.scale\r\n    const Roots = Intervals.map(v => Note.interval(v).chord().tonic())\r\n    const Notes = Roots.map(v => Teoria.note(v).chord().notes().toString().split(','))\r\n\r\n    return { Note, Scale, Chord, Intervals, Roots, Notes }\r\n  }\r\n  //* Return musical scale for any given note and valid scale name. ('C', 'blues') -> ['A', 'C#',...]\r\n  static ScaleNotes = (noteChar, scaleName) => Teoria.note(noteChar).scale(scaleName).simple()\r\n  //* Transform any note char or chord name to array of notes, which play in this chord\r\n  static ChordNotes = noteChar => Teoria.note(noteChar).chord().notes().toString().split(',')\r\n  //* Return next interval note, for any note char and interval value. Work with 'third' or 'second' interval names too\r\n  static IntervalNotes = (noteChar, step) => Teoria.note(noteChar).interval(step).chord().notes().toString().split(',')\r\n  //* Return many of Teoria.js data and methods about music note char and scale name.\r\n  static NoteValues = (noteChar, scaleName) => {\r\n    const Note = Teoria.note(noteChar)\r\n    const Scale = Note.scale(scaleName)\r\n    const Chord = Note.chord().notes().toString().split(',')\r\n    const Interval = Note.interval(Teoria.note('a'))\r\n    const Intervals = {\r\n      scale: Scale.scale.map(v => this.ChordNotes(Note.interval(v))),\r\n      steps: INTERVAL_SYMBOLS.map(v => this.ChordNotes(Note.interval(v)))\r\n    }\r\n\r\n    const Info = `Note from Note: ${scaleName}\r\n  Note: ${Note.toString()}\r\n  Note.octave: ${Note.octave()}\r\n  Note.duration: ${Note.duration.toString()}\r\n  Note.accidental: ${Note.accidental()}\r\n  Note.accidentalValue: ${Note.accidentalValue()}\r\n  Note.key: ${Note.key()}\r\n  Note.midi: ${Note.midi()}\r\n  Note.fq: ${Note.fq()}\r\n  Note.chroma: ${Note.chroma()}\r\n  Note.interval1: ${Note.interval('P1').chord().notes().toString()}\r\n  Note.interval2: ${Note.interval('M2').chord().notes().toString()}\r\n  Note.interval3: ${Note.interval('M3').chord().notes().toString()}\r\n  Note.interval4: ${Note.interval('P4').chord().notes().toString()}\r\n  Note.interval5: ${Note.interval('P5').chord().notes().toString()}\r\n  Note.interval6: ${Note.interval('M6').chord().notes().toString()}\r\n  Note.interval7: ${Note.interval('M7').chord().notes().toString()}\r\n  Note.chord: ${Note.chord().notes().toString()}\r\n  Note.helmholtz: ${Note.helmholtz()}\r\n  Note.scientific: ${Note.scientific()}\r\n  Note.enharmonics: ${Note.enharmonics()}\r\n  Note.durationInSeconds: ${Note.durationInSeconds()}\r\n  Note.durationName: ${Note.durationName()}\r\n  Note.scaleDegree: ${Note.scaleDegree(Note.scale(scaleName))}\r\n  Note.solfege: ${Note.solfege(Note.scale(scaleName))}\r\n  Note.toString: ${Note.toString()}\r\n  \r\n  Scale from Note: ${scaleName} and Scale: ${scaleName}:\r\n  Scale:  ${Scale.simple().toString()}\r\n  Scale.name:  ${Scale.name.toString()}\r\n  Scale.tonic:  ${Scale.tonic.toString()}\r\n  Scale.notes:  ${Scale.notes().toString()}\r\n  Scale.simple:  ${Scale.simple().toString()}\r\n  Scale.type:  ${Scale.type().toString()}\r\n  \r\n  Chord from Note: ${noteChar}\r\n  Chord: ${Chord.toString()}\r\n  Chord.root: ${Chord.root.toString()}\r\n  Chord.name: ${Chord.name}\r\n  Chord.notes: ${Chord.notes().toString()}\r\n  Chord.simple: ${Chord.simple()}\r\n  Chord.bass: ${Chord.bass().toString()}\r\n  Chord.voicing: ${Chord.voicing().toString()}\r\n  Chord.get: ${Chord.get('third').toString()}\r\n  Chord.quality: ${Chord.quality()}\r\n  Chord.dominant: ${Chord.dominant().toString()}\r\n  Chord.subdominant: ${Chord.subdominant().toString()}\r\n  Chord.parallel: ${Chord.parallel().toString()}\r\n  Chord.interval: ${Chord.interval('P5').toString()}\r\n  Chord.chordType: ${Chord.chordType()}\r\n  Chord.toString: ${Chord.toString()}\r\n  \r\n  Interval from Note: ${noteChar} and Scale: ${scaleName}:\r\n  Interval: ${Interval.toString()}\r\n  Interval.coord: ${Interval.coord.toString()}\r\n  Interval.number: ${Interval.number().toString()}\r\n  Interval.value: ${Interval.value().toString()}\r\n  Interval.base: ${Interval.base().toString()}\r\n  Interval.type: ${Interval.type().toString()}\r\n  Interval.quality: ${Interval.quality().toString()}\r\n  Interval.qualityValue: ${Interval.qualityValue().toString()}\r\n  Interval.direction: ${Interval.direction().toString()}\r\n  Interval.semitones: ${Interval.semitones().toString()}\r\n  Interval.simple: ${Interval.simple().toString()}\r\n  Interval.octaves: ${Interval.octaves().toString()}\r\n  Interval.isCompound: ${Interval.isCompound().toString()}`\r\n\r\n    return { Note, Scale, Chord, Interval, Intervals, Info }\r\n  }\r\n  //* Multiply Array by given value. For Generate Long and unical phrases\r\n  static ArrayExtend = (array = [1], times = 10) =>\r\n    this.Array(times)\r\n      .map(v => array.flat())\r\n      .flat()\r\n  //* Note step Interval chord notes\r\n  static stepInterval = (noteChar, step) => Teoria.note(noteChar).interval(step).chord().notes().toString().split(',')\r\n  //* Note Interval Notes in lot of variations\r\n  static NoteIntervalNotes = noteChar => {\r\n    const intervalNotes = INTERVAL_SYMBOLS.map(step => this.stepInterval(noteChar, step)).join()\r\n    const chordNotes = intervalNotes.map(this.ChordNotes)\r\n    const chordPhrases = chordNotes.map(chordNotes => this.ArrayShuffle(chordNotes))\r\n    const shuffled = chordPhrases.map(v => this.ArrayShuffle([...v, ...v, ...v, ...v, ...v]))\r\n\r\n    const sources = { intervalNotes, chordNotes, chordPhrases, shuffled }\r\n    const merged = this.ArrayMerge(intervalNotes, chordNotes, chordPhrases, shuffled)\r\n\r\n    const short = merged.filter(v => v.length < 10)\r\n    const long = merged.filter(v => v.length > 10)\r\n    const onStart = merged.filter(v => v[0] === noteChar)\r\n    const onEnd = merged.filter(v => v[v.length] === noteChar)\r\n    const many = merged.filter(v => [...v].filter(char => char === noteChar).length > 1)\r\n    const once = merged.filter(v => [...v].filter(char => char === noteChar).length === 1)\r\n\r\n    const phrases = { short, long, onStart, onEnd, many, once }\r\n\r\n    return { noteChar, sources, phrases, merged }\r\n  }\r\n  //* Return text message with given object statistics. For React, and strange bugs\r\n  static ObjStat = obj => {\r\n    const keys = Object.keys(obj)\r\n    const values = Object.values(obj)\r\n    const entries = Object.entries(obj)\r\n\r\n    return `Object: ${obj}\\nKeys: ${keys.length}\\nValues: ${values.length}\\nEntries: ${entries.length}`\r\n  }\r\n}\r\n//! Validators for fast check values\r\nexport class Validate {\r\n  static isValid = result => !result.error && result.value && true\r\n  static Boolean = v => this.isValid(Joi.boolean().validate(v))\r\n  static String = v => this.isValid(Joi.string().validate(v))\r\n  static Array = v => this.isValid(Joi.array().validate(v))\r\n  static Object = v => this.isValid(Joi.object().validate(v))\r\n  static Range = v => this.isValid(Joi.number().min(0.01).max(0.99).validate(v))\r\n  static Number = v => this.isValid(Joi.number().min(1).max(100).validate(v))\r\n  static PowerOfTwo = v => this.isValid(Joi.number().min(1).max(64).validate(v))\r\n  static Octave = v => this.isValid(Joi.number().min(1).max(6).validate(v))\r\n  static NoteChar = v =>\r\n    this.isValid(\r\n      Joi.string()\r\n        .min(1)\r\n        .max(2)\r\n        .pattern(/^[a-g#]+$/i)\r\n        .validate(v)\r\n    )\r\n  static NoteCharAndOctave = v =>\r\n    this.isValid(\r\n      Joi.string()\r\n        .min(2)\r\n        .max(3)\r\n        .pattern(/^[a-g#]+[1-6]$/i)\r\n        .validate(v)\r\n    )\r\n  static NotesArray = v => this.isValid(Joi.array().items(this.NoteChar).validate(v))\r\n  static DurationSymbol = v =>\r\n    this.isValid(\r\n      Joi.string()\r\n        .pattern(/^[ntms]$/i)\r\n        .validate(v)\r\n    )\r\n  static DurationRelative = v =>\r\n    this.isValid(\r\n      Joi.string()\r\n        .pattern(/^1|2|4|8|16|32|64[nmts]$/i)\r\n        .validate(v)\r\n    )\r\n  static DurationAbsolute = v => this.isValid(Joi.number().min(0.001).max(10000).validate(v))\r\n}\r\n//! Matchers for easy extract values from strings\r\nexport class Matchers {\r\n  static noteChar = str => new RegExp('^[a-g#]+', 'i').exec(str).join()\r\n  static octave = str => new RegExp('\\\\d$', 'i').exec(str).join()\r\n  static durationValue = str => new RegExp('^\\\\d+', 'i').exec(str).join()\r\n  static durationSymbol = str => new RegExp('[ntms]$', 'i').exec(str).join()\r\n}\r\n//! Constant Values for using in generate values, validate, etc...\r\nexport const NOTES = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'F', 'E', 'E#', 'G', 'G#']\r\nexport const SCALES = [\r\n  'major',\r\n  'minor',\r\n  'ionian',\r\n  'dorian',\r\n  'phrygian',\r\n  'lydian',\r\n  'mixolydian',\r\n  'aeolian',\r\n  'locrian',\r\n  'majorpentatonic',\r\n  'minorpentatonic',\r\n  'chromatic',\r\n  'harmonicchromatic',\r\n  'blues',\r\n  'doubleharmonic',\r\n  'flamenco',\r\n  'harmonicminor',\r\n  'melodicminor',\r\n  'wholetone'\r\n]\r\nexport const SCALES_SHORT = [\r\n  'major',\r\n  'minor',\r\n  'majorpentatonic',\r\n  'minorpentatonic',\r\n  'chromatic',\r\n  'harmonicchromatic',\r\n  'blues',\r\n  'doubleharmonic',\r\n  'flamenco',\r\n  'harmonicminor',\r\n  'melodicminor',\r\n  'wholetone'\r\n]\r\nexport const TUNINGS = {\r\n  'E Standart': ['E2', 'A2', 'D3', 'G3', 'B4', 'E4'],\r\n  'Drop D': ['D2', 'A2', 'D3', 'G3', 'B4', 'E4'],\r\n  'Drop C': ['C2', 'G2', 'C3', 'F3', 'A4', 'D4'],\r\n  'Drop B': ['B2', 'F#2', 'B3', 'E3', 'G#3', 'C#4']\r\n}\r\nexport const INSTRUMENT_NAMES = [\r\n  'bass-electric',\r\n  'bassoon',\r\n  'cello',\r\n  'contrabass',\r\n  'guitar-acoustic',\r\n  'guitar-electric',\r\n  'guitar-nylon',\r\n  'organ',\r\n  'piano',\r\n  'saxophone',\r\n  'violin'\r\n]\r\nexport const SYNTH_NAMES = [\r\n  'AMSynth',\r\n  'FMSynth',\r\n  'DuoSynth',\r\n  'MembraneSynth',\r\n  'MetalSynth',\r\n  'MonoSynth',\r\n  'NoiseSynth',\r\n  'PluckSynth',\r\n  'PolySynth',\r\n  'Synth'\r\n]\r\nexport const SAMPLE_NAMES = INSTRUMENT_NAMES\r\nexport const DURATION_SYMBOLS = ['n', 't', 'm', 'n']\r\nexport const NOTE_COLORS = {\r\n  A: '#00ff00',\r\n  'A#': '#8000ff',\r\n  AB: '#8000ff',\r\n  B: '#00ffff',\r\n  'B#': '#ff80c0',\r\n  BB: '#ff80c0',\r\n  C: '#ff0000',\r\n  D: '#ffff00',\r\n  'D#': '#ff00ff',\r\n  DB: '#ff00ff',\r\n  E: '#0080c0',\r\n  'E#': '#808080',\r\n  EB: '#808080',\r\n  F: '#800000',\r\n  G: '#ff8000',\r\n  'G#': '#8080c0',\r\n  GB: '#8080c0'\r\n}\r\nexport const INTERVAL_SYMBOLS = ['P1', 'M2', 'M3', 'P4', 'P5', 'M6', 'M7']\r\nexport const TUNING_NAMES = Object.keys(TUNINGS)\r\nexport const COLORS = Object.values(NOTE_COLORS)\r\nexport const SAMPLES = SAMPLE_NOTES\r\n\r\n//! Old Functions, for faq\r\nexport const randNumber = (max = 6) => Math.ceil(Math.random() * max)\r\n\r\n// export const MusicHelpers = {\r\n//   rand: {\r\n//     note: () => {\r\n//       const note = `${randomArrayElement(values.note)}${1 + Math.ceil(Math.random() * 8)}`\r\n//       return { note, helper: Teoria.note(note) }\r\n//     },\r\n//     scale: () => {\r\n//       const Note = Teoria.note(`${randomArrayElement(values.note)}${1 + Math.ceil(Math.random() * 8)}`)\r\n//       return Note.scale(randomArrayElement(values.scale)).simple()\r\n//     },\r\n//     tuning: () => randomArrayElement(values.tuning),\r\n//     duration: () => `${2 * Math.ceil(Math.random() * 5)}n`,\r\n//     octave: () => 1 + Math.ceil(Math.random() * 5),\r\n//     sequence: (size = [8, 12], key = 'C3', scale = 'minorpentatonic') => {\r\n//       const Note = Teoria.note(key)\r\n//       const Scale = Note.scale(scale).simple()\r\n\r\n//       console.log(Note)\r\n//       console.log(Scale)\r\n\r\n//       console.log(size, key, scale)\r\n\r\n//       const shortSeq = Array(size[0])\r\n//         .fill(1)\r\n//         .map(el => ({ note: `${randomArrayElement(Scale)}${randNumber(4)}`, duration: `${2 ** randNumber(5)}n` }))\r\n//       const playable = Array(size[1]).fill(shortSeq)\r\n\r\n//       console.log(playable)\r\n\r\n//       return playable\r\n//     }\r\n//   },\r\n//   getScale: (key, name) => Teoria.note(`${key}4`).scale(name),\r\n//   getKey: (key, octave = this.rand.octave) => `${key}${octave}`\r\n// }\r\n\r\nexport const randomRange = () => Math.random()\r\nexport const randomNumber = (max = 100, min = 0) => ~~(min + randomRange() * (max - min))\r\nexport const randomPowerOfTwo = (max = 5) => 2 ** randomNumber(max, 2)\r\nexport const randomArrayElement = arr => (arr.length ? arr[randomNumber(arr.length)] : null)\r\nexport const randomBoolean = () => randomNumber() > 50\r\nexport const randomArrayShuffle = arr => arr.sort((a, b) => (randomBoolean() ? 1 : -1))\r\nexport const randomArrayElementChange = arr => {\r\n  const el = randomArrayElement(arr)\r\n  const ind = randomNumber(arr.length)\r\n  arr[ind] = el\r\n  return arr\r\n}\r\nexport const randomArrayElementDoubled = arr => {\r\n  const { note, velocity } = randomArrayElement(arr) ?? { note: 'c2', duration: '4n' }\r\n  const ind = randomNumber(arr.length)\r\n  arr[ind] = [[{ note, velocity, duration: '16n' }], [{ note, velocity, duration: '16n' }]]\r\n  return arr\r\n}\r\nexport const randomDurationSymbol = (durations = ['n', 't']) => randomArrayElement(durations)\r\nexport const randomScale = () => randomArrayElement(SCALES)\r\nexport const randomBpm = () => randomNumber(60, 100)\r\nexport const randomDuration = () => `${randomPowerOfTwo(4)}${randomDurationSymbol()}`\r\nexport const randomNote = (arr = NOTES) => randomArrayElement(arr)\r\nexport const randomNoteAndOctave = (arr = NOTES, octave = 2) => `${randomArrayElement(arr)}${octave}`\r\nexport const noteScale = (noteChar, scaleName) => {\r\n  if (!noteChar || !scaleName) {\r\n    throw new Error(`Invalid noteChar: ${noteChar} or scaleName: ${scaleName} at Helpers.noteScale()`)\r\n  }\r\n\r\n  const Note = Teoria.note(noteChar)\r\n  const Scale = Note.scale(scaleName).simple()\r\n\r\n  return { Note, Scale }\r\n}\r\nexport const randomPatterns = (arr = NOTES, len = 4) => {\r\n  const pattern = Array(len)\r\n    .fill(1)\r\n    .map(v => randomArrayElement(arr))\r\n  const patternsVariations = Array(len ** 2)\r\n    .fill(pattern)\r\n    .map(v => v.sort(() => Math.random() - 0.5))\r\n  const unicalsPatterns = [...new Set([...patternsVariations])]\r\n\r\n  return unicalsPatterns\r\n}\r\nexport const randomNoteObject = (notesArray = NOTES, octave = 2) => {\r\n  const note = randomArrayElement(notesArray)\r\n  return {\r\n    note,\r\n    noteBass: `${note}2`,\r\n    noteDrum: `${note}1`,\r\n    noteSynth: `${note}${randomNumber(5, octave)}`,\r\n    duration: randomDuration(),\r\n    velocity: randomRange()\r\n  }\r\n}\r\nexport const splitNoteAndOctave = str => {\r\n  const note = str.match(/[a-g]+/i)?.[1] ?? null\r\n  const octave = str.match(/[0-9]+/i)?.[1] ?? null\r\n  return { note, octave }\r\n}\r\nexport const objStat = obj => Object.entries(obj).reduce((acc, val) => (acc += `\\n${val.join(' -> ')}`), '')\r\nexport const randomNumbers = (max = 100) =>\r\n  Array(100)\r\n    .fill(1)\r\n    .map(v => randomNumber(max))\r\nexport const randomMelody = ({ key, scale, octave, size, parts }) => {\r\n  const mainNote = `${key}${octave}`\r\n  const Note = Teoria.note(mainNote)\r\n  const Scale = Note.scale(scale).simple()\r\n\r\n  const mainNotes = Array(size)\r\n    .fill(1)\r\n    .map(v => randomNoteObject(Scale, octave))\r\n    .map(v => {\r\n      if (randomRange() > 0.7) {\r\n        return [v, v]\r\n      } else {\r\n        return v\r\n      }\r\n    })\r\n\r\n  const melodyBass = [...mainNotes]\r\n  const melodyDrum = mainNotes.map(v => {\r\n    const range = randomRange()\r\n    if (range > 0.7) {\r\n      return [v, v]\r\n    } else {\r\n      return v\r\n    }\r\n    // } else if (range > 0.3) {\r\n    //   return randomArrayElement(mainNotes)\r\n    // } else {\r\n    //   return v\r\n    // }\r\n  })\r\n  const melodyPart = mainNotes.map(v => {\r\n    const range = randomRange()\r\n    if (range > 0.7) {\r\n      return [v, v]\r\n    } else if (range > 0.3) {\r\n      // return v\r\n      return randomArrayElement(mainNotes)\r\n    } else {\r\n      return v\r\n    }\r\n  })\r\n  const melodyBassFull = Array(parts)\r\n    .fill(melodyBass)\r\n    .reduce((acc, val) => [...acc, ...val], [])\r\n  const melodyDrumFull = Array(parts)\r\n    .fill(melodyDrum)\r\n    .reduce((acc, val) => [...acc, ...val], [])\r\n  const melodyPartFull = Array(parts)\r\n    .fill(melodyPart)\r\n    .reduce((acc, val) => [...acc, ...val], [])\r\n\r\n  // const melodyPart = Array(size)\r\n  //   .fill(1)\r\n  //   .map(v => randomNoteObject(Scale, octave))\r\n  const melodyShuffled = Array(parts)\r\n    .fill(1)\r\n    .map(val => randomArrayShuffle(melodyPart))\r\n    .reduce((acc, val) => [...acc, ...randomArrayShuffle(melodyPart)], [])\r\n  const melodyDoubled = Array(parts)\r\n    .fill(1)\r\n    .reduce((acc, val) => [...acc, ...randomArrayElementDoubled(melodyPart)], [])\r\n\r\n  return {\r\n    mainNotes,\r\n    melodyBass: melodyBassFull,\r\n    melodyDrum: melodyDrumFull,\r\n    melodyPart: melodyPartFull\r\n  }\r\n  // return {\r\n  //   melodyBass,\r\n  //   melodyDrum,\r\n  //   melodyPart\r\n  // }\r\n  // return melodyPart\r\n  // return melodyShuffled\r\n  // return melodyDoubled\r\n}\r\nexport const getInstrument = ({ instrument }) => {\r\n  const synth = new Tone.PolySynth({ volume: 0 }).toDestination()\r\n  const drum = new Tone.PolySynth({ volume: -5 }).toDestination()\r\n  const bass = new Tone.PolySynth({ volume: 0 }).toDestination()\r\n  // const drum = new Tone.PluckSynth({ volume: -5 }).toDestination()\r\n  // const bass = new Tone.Synth({ volume: 0 }).toDestination()\r\n  return { synth, bass, drum }\r\n}\r\nexport const getTrack = ({ instrument, melody, transport }) => {\r\n  console.log('melody', melody)\r\n  const trackBass = new Tone.Sequence(\r\n    (time, { noteBass, duration, velocity }) => {\r\n      console.log(noteBass)\r\n      // instrument.bass.triggerAttackRelease(noteBass, duration, time, velocity)\r\n    },\r\n    melody.melodyBass,\r\n    '4n'\r\n  ).set({ humanize: true, probability: 1, playbackRate: 1 })\r\n  const trackDrum = new Tone.Sequence(\r\n    (time, { noteDrum, duration, velocity }) => {\r\n      console.log(noteDrum)\r\n      // instrument.drum.triggerAttackRelease(noteDrum, duration, time, velocity)\r\n    },\r\n    melody.melodyDrum,\r\n    '4n'\r\n  ).set({ humanize: true, probability: 1, playbackRate: 1.5 })\r\n  const trackPart = new Tone.Sequence(\r\n    (time, { noteSynth, duration, velocity }) => {\r\n      console.log(`Note: ${noteSynth} Duration: ${duration} Velocity: ${velocity}`)\r\n      instrument.synth.triggerAttackRelease(noteSynth, duration, time, velocity)\r\n    },\r\n    melody.melodyPart,\r\n    '4n'\r\n  ).set({ humanize: true, probability: 1, playbackRate: 1 })\r\n  const track = {\r\n    stop: (time = 0) => {\r\n      trackPart.stop(time)\r\n      // trackBass.stop(time)\r\n      // trackDrum.stop(time)\r\n    },\r\n    start: (time = 0) => {\r\n      trackPart.start(time)\r\n      // trackBass.start(time)\r\n      // trackDrum.start(time)\r\n    }\r\n  }\r\n\r\n  transport.set({ bpm: randomBpm() })\r\n\r\n  return track\r\n}\r\nexport const getTransport = () => Tone.Transport\r\n","C:\\Programming\\myprojects\\src\\components\\samples\\index.js",[],{"ruleId":"86","replacedBy":"87"},{"ruleId":"88","replacedBy":"89"},{"ruleId":"90","severity":1,"message":"91","line":4,"column":8,"nodeType":"92","messageId":"93","endLine":4,"endColumn":12},{"ruleId":"90","severity":1,"message":"94","line":34,"column":28,"nodeType":"92","messageId":"93","endLine":34,"endColumn":39},{"ruleId":"90","severity":1,"message":"95","line":34,"column":41,"nodeType":"92","messageId":"93","endLine":34,"endColumn":53},{"ruleId":"90","severity":1,"message":"96","line":34,"column":69,"nodeType":"92","messageId":"93","endLine":34,"endColumn":80},{"ruleId":"97","severity":1,"message":"98","line":39,"column":29,"nodeType":"99","messageId":"100","endLine":39,"endColumn":31},{"ruleId":"86","replacedBy":"101"},{"ruleId":"88","replacedBy":"102"},{"ruleId":"90","severity":1,"message":"103","line":131,"column":13,"nodeType":"92","messageId":"93","endLine":131,"endColumn":17},{"ruleId":"90","severity":1,"message":"104","line":131,"column":33,"nodeType":"92","messageId":"93","endLine":131,"endColumn":42},{"ruleId":"90","severity":1,"message":"105","line":686,"column":9,"nodeType":"92","messageId":"93","endLine":686,"endColumn":23},{"ruleId":"90","severity":1,"message":"106","line":690,"column":9,"nodeType":"92","messageId":"93","endLine":690,"endColumn":22},{"ruleId":"90","severity":1,"message":"107","line":719,"column":9,"nodeType":"92","messageId":"93","endLine":719,"endColumn":18},{"ruleId":"90","severity":1,"message":"108","line":727,"column":9,"nodeType":"92","messageId":"93","endLine":727,"endColumn":18},"no-native-reassign",["109"],"no-negated-in-lhs",["110"],"no-unused-vars","'View' is defined but never used.","Identifier","unusedVar","'figureWidth' is assigned a value but never used.","'figureHeight' is assigned a value but never used.","'notesColors' is assigned a value but never used.","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside",["109"],["110"],"'Note' is assigned a value but never used.","'Intervals' is assigned a value but never used.","'melodyShuffled' is assigned a value but never used.","'melodyDoubled' is assigned a value but never used.","'trackBass' is assigned a value but never used.","'trackDrum' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]